Go apps 101
How to build & test them 
20 Oct 2019

Adelina Simion
Software Engineer, Deliveroo
adelina.simion@deliveroo.co.uk
@DeliverooEng
@classic_addetz

* About me
Software engineer (Backend) at Deliveroo, London

- M.Sc. Mathematical Modelling & Computing from Technical University of Denmark
- Living in London 5 years ðŸ‡¬ðŸ‡§
- Java for 5 years, Go for 1 year or so 
- First time running a workshop
.image images/deliveroo_main.png _ 650

* About Deliveroo

- Deliveroo is an online food delivery company founded in 2013 in London
- Currently operating in 13 markets
- The business is divided into 3 groups: *Consumer*, *Rider* & *Restaurants*
- I am working in the *Consumer* group, focused on improving consumer experience

.image images/deliveroo-rider.png _ 600

* Go at Deliveroo

- Initially built in Ruby on Rails, *Deliveroo* is a Go convert!
- Most of our new *Consumer* projects are written in Go.
- Among many projects, Go already powers our *restaurant* *list*.

.image images/deliveroo-florence-no-logo.png _ 800

* Workshop goals 
We will spend the next 3 or so hours together learning *Go* fundamentals and experimenting with *Go* apps. 
The workshop will be modular, with each section building on top of the previous one.
Solutions will be provided for each exercise.

At the end, you will have built:
- An app which saves food orders to an in-memory database 
- An app which presents food orders via REST
- An app which is easy to extend and test

.image images/gopher_go.png _ 500

* Agenda 
- Discuss Go fundamentals as needed
- Setup and explore the repo starting point 
- Implement the order processing app
- Present our orders via REST and think about our error cases
- Unit testing & mock generation of the app
- Round up & finish off the day 

.image images/golab-logo.png _ 700

* Setup
- Installation instructions found on the project `README`
.link https://github.com/addetz/go_apps_101#go-setup
- Setup your Go environment
- Setup `$GOPATH` & `$GO111MODULE`
- Clone our repo in your `$GOPATH/src/github.com`
- Develop with any IDE you prefer
.link https://github.com/addetz/go_apps_101 github.com/addetz/go_apps_101
.image images/go_logo.png _ 400


* Exercise - Hello, world!
Letâ€™s test our Go setup by running `hello/hello_world.go`
.play exercises/hello.go
Run your code with 
.code exercises/ex_go_run_hello.go
.image https://media.giphy.com/media/MeAJb6e5Obb8Y/giphy.gif

* Packages
Go files *must* start with a `package` declaration.
It is *encouraged*, but not required that the package name be the same as its folder.
Executable programs must have a `main` package that declares a `main()` function that receives *no* *arguments* and has *no* *return* values.
Only one `main` method may be declared per package.
.code fundamentals/go_packages.go
.image https://media.giphy.com/media/3oKIP9cJEOO9ljKoCc/giphy.gif _ 200

* Importing packages with Go modules
Go does not have a central repository for downloading packages.
Packages are imported using the `import` keyword.
.code fundamentals/go_imports.go /START OMIT/,/END OMIT/
Packages are then downloaded and installed with
.code fundamentals/go_get_package.go
Once the download is complete, it saves the package content inside `github.com/external/package` directory under `$GOPATH/src`

We have cloned our repo into `$GOPATH/src/github.com`.
This allows `Go` modules to resolve all our project dependencies locally, since the path matches the paths we have declared for import.

* Skeleton of our repo
Let's explore our cloned repo...
.code exercises/repo_structure.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/vl8ncD72EnhoA/giphy.gif _ 300

* What we will build 
.image images/app_diagram_overview.png

* Keywords
The following are *reserved* keywords in Go. 

.code fundamentals/go_keywords.go
.image https://media.giphy.com/media/xT9KVuimKtly3zoJ0Y/giphy.gif

* Primitives 
.code fundamentals/go_primitives.go
.image https://media.giphy.com/media/umehzEQ4uJdfO/giphy.gif _ 300

* Printing primitives
We format & print strings using the `fmt` package.
Print statements use verbs which are usually preceded by `%`.

.play fundamentals/go_print.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/gw3IWyGkC0rsazTi/giphy.gif _ 350

* Zero values
Variables declared without an explicit initial value are given their zero value.

The zero value is:

- `0` for numeric types,
- `false` for the boolean type, and
- `""` (the empty string) for strings.

.play fundamentals/go_zero.go /START OMIT/,/END OMIT/

* Declaring variables
There are 3 ways to initialize variables in Go:

.play fundamentals/go_var_init.go

* Structs - the building blocks of Go
We can define our own types in Go using _structs_.

- A struct is an aggregate data type that groups together zero or more named values of arbitrary types as a single entity
- Each value is called a _field_
- All of these fields are collected into a _single_ _entity_ that can be copied as a unit, passed to functions, stored in arrays etc.

_Structs_ may have 0 or more fields. 
.code fundamentals/go_structs.go

* Exported vs unexported names
In Go, a name is exported if it begins with a capital letter. There are no _access_ _modifiers_.
For example, `Pi` is exported from the `math` package.

.play fundamentals/go_exported_names.go

When importing a package, you can refer only to its exported names. 
Any _unexported_ names are not accessible from outside the package.

* Exercise  - Define Item struct
Fill in `models/item.go` with new fields.
.code exercises/ex_define_item.go
Uncomment `models/item_define_test.go` and run it to see it pass.
.code exercises/ex_define_item_test_run.go
*Solution*:
.code exercises/ex_item_solution.go

* Initializing Structs 
Structs are initialized in an analogous way to primitive variables. 

.play fundamentals/go_struct_init.go /START OMIT/,/END OMIT/

* Printing structs
`Structs` are also printed using `fmt` with:
 - %v to print values
 - %+v to print name & value

.play fundamentals/go_struct_print.go /START OMIT/,/END OMIT/

* Exercise - Create & print some items
Fill in `cmd/server.go` to create & print some items.
Run your program and see it print out your created items
.code exercises/ex_go_run_main.go
*Solution*:
.code exercises/ex_create_item_solution.go

.image https://media.giphy.com/media/12uXi1GXBibALC/giphy.gif _ 400


* Accessing struct fields 
Struct fields are accessed using the `.` operator.

- _Exported_ fields are accessed from any package
- _Unexported_ fields are only available in the package the `struct` is defined in

.play fundamentals/go_struct_access.go /START OMIT/,/END OMIT/

* Constants & Iota
Constants cannot be modified once they have been declared.
They are declared with the `const` keyword. 

`iota` is used in `const` declarations to simplify definitions of incrementing numbers.
The value of `iota` starts from 0 in each discreet `const` block.

.play fundamentals/go_iota.go /START OMIT/,/END OMIT/

* Exercise - Define the OrderStatus constant using iota
.code exercises/ex_order_status.go
Uncomment `models/order_status_test.go` and run it to see it pass.
.code exercises/ex_order_status_test_run.go
*Solution*:
.code exercises/ex_order_status_solution.go
.image https://media.giphy.com/media/1sSWWMNnaZLlm/giphy.gif _ 350

* Functions 
Functions in Go are *first* *class* *citizens*, meaning they are primitives. 
They are declared using the `func` keyword and support short hand notation with `:=`
.play fundamentals/go_functions.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/n4WpP39mwWrmg/giphy.gif _ 350

* Methods 
Methods allow us to namespace a function to a receiver. 
The function receiver is the _implicit_ _first_ _argument_ of a function.
Exported struct methods are accessed using the `.` operator. 

.play fundamentals/go_methods.go /START OMIT/,/END OMIT/

* Exercise - Print the price of a menu Item
Fill in our `models/item.go` with a `PrintWithPrice()` method.
.code exercises/ex_price_item.go
Uncomment `models/item_price_test.go` and run it to see it pass.
.code exercises/ex_price_item_test_run.go
*Solution*:
.code exercises/ex_item_price_solution.go

.image https://media.giphy.com/media/4lf1L0axY1vyM/giphy.gif _ 250

* Pointers 
Pointers allow us to point to the memory space of a value.
The zero value of a pointer is `nil`.
- To indicate we are expecting a pointer we use the `*` operator.
- To get the address of a value, we use the `&` operator.

.play fundamentals/go_pointers.go /START OMIT/,/END OMIT/

* When to use pointers?
As a rule of thumb, use pointers over values when:

- You want to modify values.
- You have a large (memory) value that you don't want to keep copying.
- You want to be able to return a `nil` value.

.image https://media.giphy.com/media/z9TPacKAkn4CQ/giphy.gif _ 400


* Methods on pointer receivers
Only methods declared on pointer receivers can make changes to their receiver.

.play fundamentals/go_pointer_methods.go /START OMIT/,/END OMIT/

* Exercise - Change price of a menu item
Fill in our `models/item.go` with a `ChangePrice` method.
.code exercises/ex_change_price_item.go
Uncomment `models/item_change_price_test.go` and run it to see it pass.
.code exercises/ex_change_price_item_test_run.go
*Solution*:
.code exercises/ex_item_change_price_solution.go

* Arrays
In Go, arrays are:
 
- Fixed length - once an array has allocated its size it cannot be changed
- Fixed type 
- Zero based 
- Accessed by index 

.play fundamentals/go_arrays.go /START OMIT/,/END OMIT/

* Slices
In Go, slices are: 

- Fixed type 
- Dynamically sized 
- Flexible 
- Have a pointer to an underlying array
- Can share an underlying array

.play fundamentals/go_slices.go /START OMIT/,/END OMIT/

* Slices cont'd
Great explanation of slices here: 
.link https://blog.golang.org/go-slices-usage-and-internals

A slice is a descriptor of an array segment. It consists of :

- a pointer to the array
- the length of the segment
- its capacity (the maximum length of the segment)

.image images/golang_slice_internals.png _ 500

* Exercise - Define the Order model
Fill in `models/order.go` with the models we have so far: 
.code exercises/ex_order.go
Uncomment `models/order_define_test.go` and run it to see it pass.
.code exercises/ex_order_test_run.go
*Solution*:
.code exercises/ex_order_solution.go
.image https://media.giphy.com/media/tZaFa1m8UfzXy/giphy.gif _ 250

* Control flow
The `if` statement looks as it does in other language
- except that the `()` are removed and the `{}` are required.

`if` also supports short-hand notation.
All variables are then _only_ defined in statement scope.

.play fundamentals/go_control_flow.go /START OMIT/,/END OMIT/

* For loops & Ranges
The two most common ways to traverse arrays & slices in Go are the `for`-loop and the `range`. The `range` is the most popular.

.play fundamentals/go_range.go /START OMIT/,/END OMIT/

* Exercise - Implement Order total
Fill in `models/order.go` with a `Total()` method to calculate the total of the items.
*Note:* It is considered idiomatic in Go to put `Get` into getters names.
.code exercises/ex_order_total.go
Uncomment `models/order_total_test.go` and run it to see it pass
.code exercises/ex_order_total_test_run.go
*Solution*:
.code exercises/ex_order_total_solution.go

.image https://media.giphy.com/media/BMBMMfVxZ2lOM/giphy.gif _ 300

* Multiple return values
Go supports multiple return values. Notice the `()` around them.
This feature is used often in idiomatic Go, for example to return both result and error values from a function.

.play fundamentals/go_multiple_return.go /START OMIT/,/END OMIT/

*Note:* It is good practice in Go to handle error cases first.

* Our in memory database
We will be using an in memory database to save our orders.
This is implemented in `db/db.go`. It exposes the following methods.
.code exercises/ex_db_methods.go
We can use this database by passing a reference of it in the `OrderRepo`.
.code exercises/ex_order_repo_def.go

* Maps
Maps are powerful data structures that associate keys and values.
They return the zero value of the value type when attempting to retrieve a non-existent key. We use the extra `ok` return value to check whether a key exists.
.play fundamentals/go_maps.go /START OMIT/,/END OMIT/
Our in memory database is implemented using a `map`.

* Exercise - Implement the OrderRepo
Fill in `repo/order_repo.go` to allow us to save, find and delete orders using the  `db.DB`.
.code exercises/ex_order_repo.go
Uncomment `repo/order_repo_test.go` and run it to see it pass.
.code exercises/ex_order_repo_test_run.go
*Solution*:
.code exercises/ex_order_repo_solution.go

* Exercise - Create & save an order
Fill in `cmd/server.go` with a new order containing the previously created items.
Save the order to the repo and print it out in the same way as with the items.
Run your program with
.code exercises/ex_go_run_main.go
*Solution*:
.code exercises/ex_order_create_solution.go
.image https://media.giphy.com/media/3o751YUaBEePF6VMJy/giphy.gif _ 400

* Progress checkpoint!
So far, we have:

- Defined the `Item` model
- Defined the `Order` model which contains one or more items
- Implemented `OrderRepo` to save, find & delete orders

Now on to share our orders ... *WITH* *THE* *WORLD*!

.image https://media.giphy.com/media/iBEW5Amz0ztza/giphy.gif _ 300

* REpresentational State Transfer (REST) refresher

- *Resource* *based* *URIs* - endpoints are self explanatory and named after their resources. They do not contain verbs
- *HTTP* *methods* - define what the operation on the resource is ie POST for update/create, GET for fetching resource
- *HTTP* *status* *codes* - show the success/error code of the operation performed on the server
- *Message* *headers* - other parameters such as `content-type` which define the request & response format. Most APIs return `JSON` responses

.image https://media.giphy.com/media/xUOxf9lJKcBDrE6qmk/giphy.gif _ 235

* Orders API design
For our Orders REST API, _orders_ are our _resources_.
We will expose the following endpoints:
.code fundamentals/go_orders_api.go
We will return `JSON` responses.

* Anatomy of the Orders REST Server

- Our server exposes *endpoints* which are accessible by the client.
- Each endpoint has a *handler* function bound to it which calls the appropriate `OrderRepo` method
- The handler function then returns the HTTP response & status code to the server
- The server forwards the handler's response to the client.

.image https://media.giphy.com/media/VbnUQpnihPSIgIXuZv/giphy.gif _ 300

* Exercise - Starting a simple server in Go
Creating & starting servers in Go is very simple.
You will see this code in `echo/echo.go`
.code exercises/ex_simple_server.go /START OMIT/,/END OMIT/
Run the server and go to any path at `localhost:8080` to see the server echo our path.
.code exercises/ex_simple_server_run.go

* What we will build (in more detail)
The Orders REST server has the following main components.
.image images/app_diagram_handlers.png


* The Orders REST Server
Let's examine what `cmd/server` does ...

- Creates two items & an order as a testing starting point
- Creates a new `DB` and passes the reference to `OrderRepo`
- Creates a `Handler` and passes it a reference to `OrderRepo`
- Creates a router by calling the `ConfigureServer()` function
- Starts the router on port `8080`

.image https://media.giphy.com/media/3o7TKAK6dCfEQoTC2A/giphy.gif _ 350

* JSON marshal

Go offers built in support JSON encoding & decoding of custom data structures. Only exported fields will be encoded/decoded in JSON.
Tags on struct field declarations allow us to customize the encoded JSON key names.
*NOTE*: It is not considered idiomatic JSON to have uppercased fields.
.play fundamentals/go_json_marshal.go /START OMIT/,/END OMIT/


* JSON unmarshal

- The JSON marshal/encode operation converts structs into bytes which can be sent to HTTP responses.
- The JSON unmarshal/decode operation converts bytes back into structs to be used.
.play fundamentals/go_json_unmarshal.go /START OMIT/,/END OMIT/

* Handlers
As previously mentioned handlers are functions which will be invoked when the client hits a route/endpoints.
The `ConfigureServer()` function defined in `handlers/config.go` defines the route & handler associations

.code exercises/ex_configure_server.go

* What our handlers should do

- Read any request parameters ie. the `orderId` of the requested order
- Read the request body, in the case of a `POST`, and unmarshal it to the correct `struct`
- Call the corresponding `OrderRepo` operation
- Unmarshal any returned `OrderRepo` structs that might be needed as response
- Write the HTTP status code & order bytes to the response

.image https://media.giphy.com/media/3ofT5PzM67qEoeihmo/giphy.gif _ 400

* Exercise - Implement Order Server API handlers
Look at `handlers/handlers.go` and fill in the missing parts to make the method compile/run.
You should use the `writeResponse` helper method to write a REST response
.code exercises/ex_handlers.go
*Solution*:
.code exercises/ex_handlers_solution.go

* Run the Order Server
.code exercises/ex_run_server.go

- Test out the GET operations from the browser.
- Test out the POST operation using `curl` from the command line. Edit your input body data in `postBody.json`
.code exercises/ex_curl_post.go
- Test out the DELETE operation using `curl`.
.code exercises/ex_curl_delete.go

* Progress checkpoint!
So far, we have:

- Defined the `Item` model
- Defined the `Order` model which contains one or more items
- Implemented `OrderRepo` to save, find & delete orders
- Implement the Orders REST server & manually tested it.

Now on to refactor & test our order server!

.image https://media.giphy.com/media/mi6DsSSNKDbUY/giphy.gif _ 450

* Why can't we unit test our server?

- Our classes currently have a hard dependency on the database and cannot be tested without real data
- The `OrderRepo` has a hard dependency to the `DB`, so it cannot be tested in isolation
- Our application cannot be easily refactored to use another database

Therefore, we have had to do our testing manually. Some refactoring is needed!

.image https://media.giphy.com/media/3o7btY356cSVYzmFS8/giphy.gif _ 450

* Interfaces
- To implement an interface in Go, we just need to implement its methods
- Interfaces dynamically hold a reference to their underlying types
- All structs implement the empty interface - `interface{}`
- `Structs` are referred to as *concrete* types, while `interfaces` are *abstract* types
- The compiler will then automatically check that a type satisfies it
- Interfaces are _implicitly_ defined in Go
- This is known as *Duck* *Typing*

.image https://media.giphy.com/media/vIJaz7nMJhTUc/giphy.gif _ 300

* Interfaces in action
.play fundamentals/go_interfaces.go /START OMIT/,/END OMIT/

* The power of interfaces
Interfaces abstract code to make it more reusable, extensible and more testable.
They are also a way to achieve *polymorphism* in Go.

- The concrete type does not need to know about any interface
- We can write interfaces for concrete types that already exist
- We can write interfaces for other people's types, or types that appear in other packages

In Go, *interfaces* are defined in the calling code not in the defining code.


* Exercise - Create a DB interface
Extract an interface for our DB that `OrderRepo` can use as a dependency.
*NOTE*: Remember that we define interfaces in calling code in `Go`.
.code exercises/ex_db_interface.go
If defined correctly, the compiler will cast the concrete `db.DB` passed to the `OrderRepo`. Make sure the server still works.
.code exercises/ex_run_server.go
*Solution*:
.code exercises/ex_interfaces_solution.go


* Unit Testing
- Test files live next to the files they are testing and they *must* use `_test.go` as suffix
- Black box testing can be ensured by declaring tests in the `*_test` package. The compiler ignores packages ending in `_test` and allows them in the same directory
- Tests *must* be in the format `Test<Name>(*testing.T)`
- As we've seen before, tests are run using the `go test` command
.code fundamentals/go_testing.go /START OMIT/,/END OMIT/

* testing.T important methods
The testing package contains some useful methods:
.code fundamentals/go_testing_methods.go

`Error` and `Fatal` both report a test failure, but `Error` will continue with test execution, where `Fatal` will end the test.

* Generating mocks
Mock generation allows us to generate interface stubs and use them in testing.
We will use `moq`
.link https://github.com/matryer/moq

First, install `moq` using `go` `get`.
Then we can start generating mocks easily.
.code fundamentals/go_moq.go
The usage of the `moq` command is:
.code fundamentals/go_moq_usage.go

* Exercise - Generate a mock & write a test for OrderRepo
Generate a mock for the `DB` interface.
.code exercises/ex_generate_mock.go
Write tests for `OrderRepo` in `repo/order_repo_mocks_test.go` using this mock.
Use the documentation in the generated file to mock return values.
.code exercises/ex_mock_funcs.go
*Solution*:
.code exercises/ex_db_mock_solution.go

* Final progress checkpoint!
In our 3-hour workshop we have:

- Defined the `Item` model & the `Order` model
- Implemented `OrderRepo` to save, find & delete orders
- Implement the Orders REST server & manually tested it
- Decoupled the Orders application from its database
- Unit tested the `OrderRepo`

.image https://media.giphy.com/media/10hO3rDNqqg2Xe/giphy.gif _ 550

* Full Workshop Solution

The fully working *solution* can be checked out at
.code exercises/ex_full_solution.go

.image https://media.giphy.com/media/s2qXK8wAvkHTO/giphy.gif _ 500



* Further material
Go tutorials
.link https://golang.org/
The Go Programming Language
.link amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440
Effective Go
.link https://golang.org/doc/effective_go.html
Concurrency in Go
.link https://www.amazon.com/Concurrency-Go-Tools-Techniques-Developers/dp/1491941197/

