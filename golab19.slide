Go apps 101
How to build & test them 
20 Oct 2019

Adelina Simion
Software Engineer, Deliveroo
adelina.simion@deliveroo.co.uk
@DeliverooEng
@classic_addetz

* About me
Software engineer (Backend) at Deliveroo, London

- M.Sc. Mathematical Modelling & Computing from Technical University of Denmark
- Living in London 5 years ðŸ‡¬ðŸ‡§
- Java for 5 years, Go for 1 year or so 
- First time running a workshop
.image images/deliveroo_main.png _ 650

* About Deliveroo

- Deliveroo is an online food delivery company founded in 2013 in London
- Currently operating in 13 markets
- The business is divided into 3 groups: *Consumer*, *Rider* & *Restaurants*
- I am working in the *Consumer* group, focused on improving consumer experience

.image images/deliveroo-rider.png _ 600

* Go at Deliveroo

- Initially built in Ruby on Rails, *Deliveroo* is a Go convert!
- Most of our new *Consumer* projects are written in Go.
- Among many projects, Go already powers our restaurant list.

.image images/deliveroo-florence.png _ 750

* Workshop goals 
We will spend the next 3 or so hours together learning *Go* fundamentals and experimenting with *Go* apps. 
The workshop will be modular, with each section building on top of the previous one. 

At the end, you will have built: 

- An app which saves food orders to an in-memory database 
- An app which presents food orders via REST
- An app which is easy to extend and is well tested 

.image images/gopher_go.png _ 450

* Agenda 
- Discuss Go fundamentals as needed
- Setup and explore the repo starting point 
- Implement the order processing app
- Present our orders via REST and think about our error cases
- Unit testing & mock generation of the app
- Round up & finish off the day 

.image images/gopher_jumping.gif _ 250

* Setup 
- Setup your Go environment
- Setup `$GOPATH`
- Setup `$GO111MODULE`
- Clone our repo in your `GOPATH/src/github.com`
- Develop with any IDE you prefer

.link https://golang.org/doc/install golang.org/doc/install
.link https://github.com/addetz/go_apps_101 github.com/addetz/go_apps_101

.image images/go_logo.png _ 350


* Exercise - Hello, world!
Letâ€™s test our Go setup by running `hello/hello_world.go`
.play exercises/hello.go
Run your code with 
.code exercises/ex_go_run_hello.go
.image https://media.giphy.com/media/MeAJb6e5Obb8Y/giphy.gif

* Packages
As you saw in the `hello_world` example Go files *must* start with a `package` declaration.
It is *encouraged*, but not required that the package name be the same as its folder.
Executable programs must have a `main` package that declares a `main()` function that receives *no* *arguments* and has *no* *return* values.
Only one `main` method may be declared per package.
.code fundamentals/go_packages.go
.image https://media.giphy.com/media/3oKIP9cJEOO9ljKoCc/giphy.gif _ 200

* Importing packages with Go modules
Go does not have a central repository for downloading packages.
Packages are imported using the `import` keyword.
.code fundamentals/go_imports.go /START OMIT/,/END OMIT/
Packages are then downloaded and installed with
.code fundamentals/go_get_package.go
Once the download is complete, it saves the package content inside `github.com/external/package` directory under `$GOPATH/src`

We have cloned our repo into `GOPATH/src/github.com`.
This allows `Go` modules to resolve all our project dependencies locally, since the path matches the paths we have declared for import.

* Skeleton of our repo
Let's explore our repo...
.link https://github.com/addetz/go_apps_101 github.com/addetz/go_apps_101
.code exercises/repo_structure.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/vl8ncD72EnhoA/giphy.gif _ 300

* What we will build 
.image images/app_to_build.png

* Keywords
The following are *reserved* keywords in Go. 

.code fundamentals/go_keywords.go
.image https://media.giphy.com/media/xT9KVuimKtly3zoJ0Y/giphy.gif

* Primitives 
.code fundamentals/go_primitives.go
.image https://media.giphy.com/media/umehzEQ4uJdfO/giphy.gif _ 300

* Printing primitives
We format & print strings using the `fmt` package, which we might have already seen in the `hello_world` example. 
Print statements use verbs which are usually preceded by `%`.

.play fundamentals/go_print.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/gw3IWyGkC0rsazTi/giphy.gif _ 250

* Zero values
Variables declared without an explicit initial value are given their zero value.
The zero value is:

- `0` for numeric types,
- `false` for the boolean type, and
- `""` (the empty string) for strings.

.play fundamentals/go_zero.go /START OMIT/,/END OMIT/

* Declaring variables
As previously mentioned variables that are not initialized get a _zero_ value.
There are 3 ways to initialize variables in Go:

.play fundamentals/go_var_init.go

* Structs - the building blocks of Go
We can define our own types in Go using _structs_.

- A struct is an aggregate data type that groups together zero or more named values of arbitrary types as a single entity
- Each value is called a _field_
- All of these fields are collected into a _single_ _entity_ that can be copied as a unit, passed to functions, stored in arrays etc.

_Structs_ may have 0 or more fields. 
.code fundamentals/go_structs.go

* Exported vs unexported names
In Go, a name is exported if it begins with a capital letter. 
For example, `Pi` is exported from the `math` package.

.play fundamentals/go_exported_names.go

When importing a package, you can refer only to its exported names. 
Any "unexported" names are not accessible from outside the package.

* Exercise  - Define Item struct
Fill in `models/item.go` with new fields.
.code exercises/ex_define_item.go
Uncomment `models/item_define_test.go` and run it to see it pass.
.code exercises/ex_define_item_test_run.go

We will discuss testing later, but passing tests ensure we are on the same page.
.image https://media.giphy.com/media/143vPc6b08locw/giphy.gif _ 250

* Initializing Structs 
Structs are initialized in an analogous way to primitive variables. 

.play fundamentals/go_struct_init.go /START OMIT/,/END OMIT/

* Printing structs
`Structs` are also printed using `fmt` with:
 - %v to print values
 - %+v to print name & value

.play fundamentals/go_struct_print.go /START OMIT/,/END OMIT/

* Exercise - Create some items
Fill in `cmd/server.go` to create & print some items.
Run your program with
.code exercises/ex_go_run_main.go
.image https://media.giphy.com/media/12uXi1GXBibALC/giphy.gif _ 350 

* Accessing struct fields 
Struct fields are accessed using the `.` operator.
- _Exported_ fields are accessed from any package
- _Unexported_ fields are only available in the package the `struct` is defined in.

.play fundamentals/go_struct_access.go /START OMIT/,/END OMIT/

* Constants & Iota
Constants cannot be modified once they have been declared.
They are declared with the `const` keyword. 

`iota` is used in `const` declarations to simplify definitions of incrementing numbers.
The value of iota starts from 0 in each discreet const block.

.play fundamentals/go_iota.go /START OMIT/,/END OMIT/

* Exercise - Define the OrderStatus constant using iota
.code exercises/ex_order_status.go
Uncomment `models/order_status_test.go` and run it to see it pass.
.code exercises/ex_order_status_test_run.go
.image https://media.giphy.com/media/1sSWWMNnaZLlm/giphy.gif _ 350

* Functions 
Functions in Go are *first* *class* *citizens*, meaning they are primitives. 
They are declared using the `func` keyword and support short hand notation with `:=`
.play fundamentals/go_functions.go /START OMIT/,/END OMIT/
.image https://media.giphy.com/media/n4WpP39mwWrmg/giphy.gif _ 350

* Methods 
Methods allow us to namespace a function to a receiver. 
The function receiver is the implicit first argument of a function. 
Exported struct methods are accessed using the `.` operator. 

.play fundamentals/go_methods.go /START OMIT/,/END OMIT/

* Exercise - Print the price of a menu Item
Fill in our `models/item.go` with a `PrintWithPrice()` method that will return the price for the item.
.code exercises/ex_price_item.go
Uncomment `models/item_price_test.go` and run it to see it pass.
.code exercises/ex_price_item_test_run.go
.image https://media.giphy.com/media/4lf1L0axY1vyM/giphy.gif _ 350

* Pointers 
Pointers allow us to point to the memory space of a value.
The zero value of a pointer is `nil`.
To indicate we are expecting a pointer we use the `*` operator. 
To get the address of value, we use the `&` operator. 

.play fundamentals/go_pointers.go /START OMIT/,/END OMIT/

* When to use pointers?
As a rule of thumb, use pointers over values when:

- You want to modify values.
- You have a large (memory) value that you don't want to keep copying.
- You want to be able to return a `nil` value.

.image https://media.giphy.com/media/z9TPacKAkn4CQ/giphy.gif _ 400


* Methods on pointer receivers
Only methods declared on pointer receivers can make changes to instance they are being called.

.play fundamentals/go_pointer_methods.go /START OMIT/,/END OMIT/

* Exercise - Change price of a menu item
Fill in our `models/item.go` with a `ChangePrice` method that will change the price & currency code of a menu item.
.code exercises/ex_change_price_item.go
Uncomment `models/item_change_price_test.go` and run it to see it pass.
.code exercises/ex_change_price_item_test_run.go

.image https://media.giphy.com/media/aRjH97A7rK74c/giphy.gif _ 250

* Arrays
In Go, arrays are:
 
- Fixed length - once an array has allocated its size it cannot be changed
- Fixed type 
- Zero based 
- Accessed by index 

.play fundamentals/go_arrays.go /START OMIT/,/END OMIT/

* Slices
In Go, slices are: 

- Fixed type 
- Dynamically sized 
- Flexible 
- Have a pointer to an underlying array
- Can share an underlying array

.play fundamentals/go_slices.go /START OMIT/,/END OMIT/

* Slices cont'd
Great explanation of slices here: 
.link https://blog.golang.org/go-slices-usage-and-internals

A slice is a descriptor of an array segment. It consists of :

- a pointer to the array
- the length of the segment
- its capacity (the maximum length of the segment)

.image images/golang_slice_internals.png _ 500

* Exercise - Define the Order model
Fill in `models/order.go` with the models we have so far: 
.code exercises/ex_order.go
Uncomment `models/order_define_test.go` and run it to see it pass.
.code exercises/ex_order_test_run.go

.image https://media.giphy.com/media/tZaFa1m8UfzXy/giphy.gif _ 300

* Control flow
The `if` statement looks as it does in other languages, except that the `()` are removed and the `{}` are required.
`if` also supports short-hand notation with all variables in statement scope. 

.play fundamentals/go_control_flow.go /START OMIT/,/END OMIT/

* For loops & Ranges
The two most common ways to travers arrays & slices in Go are the `for`-loop and the `range`. The `range` is the most popular. 

.play fundamentals/go_range.go /START OMIT/,/END OMIT/

* Exercise - Implement Order total
Fill in `models/order.go` with a `Total()` method.
This should calculate the order total of the items array by using the `range` operator. 
.code exercises/ex_order_total.go
Uncomment `models/order_total_test.go` and run it to see it pass
.code exercises/ex_order_total_test_run.go

*Note:* It is considered idiomatic in Go to put `Get` into getters names.

.image https://media.giphy.com/media/BMBMMfVxZ2lOM/giphy.gif _ 300

* Multiple return values
Go supports multiple return values. Notice the `()` around them.
This feature is used often in idiomatic Go, for example to return both result and error values from a function.

.play fundamentals/go_multiple_return.go /START OMIT/,/END OMIT/

*Note:* It is good practice in Go to handle error cases first.

* Our in memory database
We will be using an in memory database to save our orders.
This is implemented in `db/db.go`. It exposes the following methods.
.code exercises/ex_db_methods.go
We can use this database by passing a reference of it in the `OrderRepo`.
.code exercises/ex_order_repo_def.go

* Maps
Maps are powerful data structures that associate keys and values.
They return the zero value of the value type when attempting to retrieve a non-existent key.
We use the extra `ok` return value to check whether a key exists.
.play fundamentals/go_maps.go /START OMIT/,/END OMIT/
Our in memory database is implemented using a `map`.

* Exercise - Implement the OrderRepo
Fill in `repo/order_repo.go` to allow us to save, find and delete orders.
.code exercises/ex_order_repo.go
Uncomment `repo/order_repo_test.go` and run it to see it pass.
.code exercises/ex_order_repo_test_run.go

* Progress checkpoint!
So far, we have:
- Defined the `Item` model
- Defined the `Order` model which contains one or more items
- Implemented `OrderRepo` to save, find & delete orders

Now on to share our orders ... WITH THE WORLD!

.image https://media.giphy.com/media/iBEW5Amz0ztza/giphy.gif _ 300

* REpresentational State Transfer (REST) refresher

- *Resource* *based* *URIs* - endpoints are self explanatory and named after their resources
- *HTTP* *methods* - define what the operation on the resource is ie POST for update/create, GET for fetching resource
- *HTTP* *status* *codes* - show the success/error code of the operation performed on the server
- *Message* *headers* - other parameters such as `content-type` which define the request & response format

.image https://media.giphy.com/media/xUOxf9lJKcBDrE6qmk/giphy.gif _ 235

* Orders API design
REST APIs use HTTP methods to present & alter resources.
Resources are presented at intuitive endpoints, which do not contain verbs.
Most REST APIs return JSON responses.

For our Orders REST API, _orders_ are our _resources_.
We will expose the following endpoints:
.code fundamentals/go_orders_api.go

* Anatomy of the Orders REST Server

- Our server exposes *endpoints* which are accessible by the client.
- Each endpoint has a *handler* function bound to it which calls the appropriate `OrderRepo` method
- The handler function then returns the HTTP response & status code to the server
- The server forwards the handler's response to the client.

.image https://media.giphy.com/media/VbnUQpnihPSIgIXuZv/giphy.gif _ 300

* Exercise - Starting a simple server in Go
Creating & starting servers in Go is very simple.
You will see this code in `echo/echo.go`
.code exercises/ex_simple_server.go /START OMIT/,/END OMIT/
Run the server and go to any path at `localhost:8080` to see the server echo our path.
.code exercises/ex_simple_server_run.go

* What we will build (in more detail)
The Orders REST server has the following main components.
.image images/app_diagram_server.png


* The Orders REST Server
Let's examine what `cmd/server` does ...

- Creates two items & an order as a testing starting point
- Creates a new `DB` and passes the reference to `OrderRepo`
- Creates a `Handler` and passes it a reference to `OrderRepo`
- Creates a router by calling the `ConfigureServer()` function
- Starts the router on port `8080`

.image https://media.giphy.com/media/3o7TKAK6dCfEQoTC2A/giphy.gif _ 350

* JSON marshal

Go offers built in support JSON encoding & decoding of custom data structures. Only exported fields will be encoded/decoded in JSON.
Tags on struct field declarations allow us to customize the encoded JSON key names.
*NOTE*: It is not considered idiomatic JSON to have uppercased fields.
.play fundamentals/go_json_marshal.go /START OMIT/,/END OMIT/


* JSON unmarshal

- The JSON marshal/encode operation converts structs into bytes which can be sent to HTTP responses.
- The JSON unmarshal/decode operation converts bytes back into structs to be used.
.play fundamentals/go_json_unmarshal.go /START OMIT/,/END OMIT/

* Handlers
As previously mentioned handlers are functions which will be invoked when the client hits a route/endpoints.
The `ConfigureServer()` function defined in `handlers/config.go` defines the route & handler associations

.code exercises/ex_configure_server.go

* What our handlers should do

- Read any request parameters ie. the `orderId` of the requested order
- Read the request body, in the case of a `POST`, and unmarshal it to the correct `struct`
- Call the corresponding `OrderRepo` operation
- Unmarshal any returned `OrderRepo` structs that might be needed as response
- Write the HTTP status code & order bytes to the response

.image https://media.giphy.com/media/3ofT5PzM67qEoeihmo/giphy.gif _ 400

* Exercise - Implement Order Server API handlers
Look at `handlers/handlers.go` and fill in the missing parts to make the method compile/run.
You should use the `writeResponse` helper method to write a REST response
.code exercises/ex_handlers.go
There is no test to run as exercise verification for now.


* Run the Order Server
.code exercises/ex_run_server.go

- Test out the GET operations from the browser.
- Test out the POST operation using `curl` from the command line. Edit your input body data in `postBody.json`
.code exercises/ex_curl_post.go
- Test out the DELETE operation using `curl`.
.code exercises/ex_curl_delete.go

* Progress checkpoint!
So far, we have:
- Defined the `Item` model
- Defined the `Order` model which contains one or more items
- Implemented `OrderRepo` to save, find & delete orders
- Implement the Orders REST server & manually tested it.

Now on to refactor & test our order server!

.image https://media.giphy.com/media/mi6DsSSNKDbUY/giphy.gif _ 500

* Why can't we unit test our server?

- Our classes currently have a hard dependency on the database and cannot be tested without real data.
- The `OrderRepo` has a hard dependency of the `DB`, so we cannot test it in isolation.
- Our application cannot be easily refactored to use another database.
- Our handlers cannot be tested without writing real responses.

Therefore, we have had to do our testing manually. Some refactoring is needed!

.image https://media.giphy.com/media/OTrcaFr7P5RIs/giphy.gif _ 350

* Interfaces
- To implement an interface in Go, we just need to implement its methods.
- The compiler will then automatically check that a type satisfies it.
- Interfaces are _implicitly_ defined in Go.
- This is known as *Duck* *Typing*.

* Interfaces in action
.play fundamentals/go_interfaces.go /START OMIT/,/END OMIT/

* The power of interfaces
Interfaces abstract code to make it more reusable, extensible and more testable.
They are also a way to achieve *polymorphism* in Go.

- The concrete type does not need to know about any interface
- We can write interfaces for concrete types that already exist
- We can write interfaces for other people's types, or types that appear in other packages

In Go, *interfaces* are defined in the calling code not in the defining code.

* Exercise - Create a DB interface
Extract an interface for our DB that `OrderRepo` can use as a dependency.
